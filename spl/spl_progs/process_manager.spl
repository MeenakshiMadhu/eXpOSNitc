// MODULE 1 - PROCESS MANAGER

alias functionNum R1;
alias PID R2;

// Free User Area Page
if (functionNum == 2) then

    alias processTableEntry R3;
    processTableEntry = PROCESS_TABLE + PID*16;
    
    // invoke Release Page function with corresponding page number
    multipush(R0, R1, R2, R3);
    alias functionNum R1;
    alias userAreaPageNum R2;
    functionNum = 2;
    userAreaPageNum = [processTableEntry + 11];
    call MEMORY_MANAGER;
    multipop(R0, R1, R2, R3);

    return;
endif;

// Exit Process
if (functionNum == 3) then

    // invoke Free Page Table function from Process Manager
    multipush(R0, R1, R2, R3);
    functionNum = 4;
    call PROCESS_MANAGER;
    multipop(R0, R1, R2, R3);

    // invoke Free User Area Page function from Process Manager
    multipush(R0, R1, R2, R3);
    functionNum = 2;
    call PROCESS_MANAGER;
    multipop(R0, R1, R2, R3);

    [PROCESS_TABLE + PID*16 + 4] = TERMINATED;
    return;
endif;

// Free Page Table 
if (functionNum == 4) then
    
    // Invalidate page table entries
    PTBR = PAGE_TABLE_BASE+ PID*20;
    PTLR = 10;
    //Library
    [PTBR+0] = -1;
    [PTBR+1] = "0000";
    [PTBR+2] = -1;
    [PTBR+3] = "0000";
    
    // for each valid entry in page table, invoke Release Page
    alias ctr R3;
    alias pageNum R4;
    ctr = 4;
    while (ctr+1 < 20) do
        if ([PTBR + ctr] != -1) then
            multipush(R0, R1, R2, R3, R4);
            alias functionNum R1;
            alias pageNum R2;
            functionNum = 2;
            pageNum = [PTBR + ctr];
            call MEMORY_MANAGER;
            multipop(R0, R1, R2, R3, R4);
        endif;
        [PTBR + ctr] = -1;
        [PTBR + ctr + 1] = "0000";
        ctr = ctr + 2;
    endwhile;
    return;
endif;