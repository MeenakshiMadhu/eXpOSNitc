// MODULE 2 - MEMORY MANAGER
print "Memory Manager";
alias functionNum R1;

// Get Free Page
if (functionNum == 1) then

    alias PID R2;

    // increment WAIT_MEM_COUNT (don't, if in busy loop)
    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] + 1;

    // while memory is full (MEM_FREE_COUNT = 0)
    // wait for memory and schedule other processes meanwhile
    while ([SYSTEM_STATUS_TABLE + 2] == 0) do
        [PROCESS_TABLE + PID*16 + 4] = WAIT_MEM;
        multipush (R0, R1, R2);
        call CONTEXT_SWITCH;
        multipop (R0, R1, R2);
    endwhile;

    // decrement WAIT_MEM_COUNT & MEM_FREE_COUNT
    [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;
    
    //loop through memory free list entries
    alias freePageNum R0;
    alias ctr R3;
    ctr = 76;
    while (ctr < 128) do
        if ([MEMORY_FREE_LIST + ctr] == 0) then
            [MEMORY_FREE_LIST + ctr] = 1;
            freePageNum = ctr;
            break;
        endif;
        ctr = ctr + 1;
    endwhile;
    breakpoint;
    return;
endif;

// Release Page
if (functionNum == 2) then
    
    alias pageNum R2;
    [MEMORY_FREE_LIST + pageNum] = [MEMORY_FREE_LIST + pageNum] - 1;
    
    if([MEMORY_FREE_LIST + pageNum] == 0) then
        // increment MEM_FREE_COUNT
        [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
    endif;

    alias ctr R3;
    ctr = 0;
    while(ctr < 16) do
        if ([PROCESS_TABLE + ctr*16 + 4] == WAIT_MEM) then
            [PROCESS_TABLE + ctr*16 + 4] = READY;
        endif;
        ctr = ctr + 1;
    endwhile;
    breakpoint;
    return;
endif;

